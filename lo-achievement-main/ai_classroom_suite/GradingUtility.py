# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/GradingUtility.ipynb.

# %% auto 0
__all__ = ['grade_settings', 'default_ai_assisted_setup', 'output_setup', 'default_ai_assisted_grading_instructions',
           'bloom_assisted_output_setup', 'bloom_assistedgrading_instructions', 'InstructorGradingConfig', 'set_css',
           'clean_keys', 'file_upload_json_to_df', 'load_json_as_df', 'pretty_print', 'save_as_csv',
           'show_json_loading_errors']

# %% ../nbs/GradingUtility.ipynb 3
import ipywidgets as widgets
from IPython.display import display, HTML
import io
import zipfile
import os
import json
import pandas as pd
import glob

# %% ../nbs/GradingUtility.ipynb 4
# "global" variables modified by mutability
grade_settings = {'learning_objectives':None,
                  'json_file_path':None,
                  'json_files':None }

# %% ../nbs/GradingUtility.ipynb 5
class InstructorGradingConfig:
    def __init__(self):
        # layouts to help with styling
        self.items_layout = widgets.Layout(width='auto')

        self.box_layout = widgets.Layout(display='flex',
                                          flex_flow='column',
                                          align_items='stretch',
                                          width='50%',
                                          border='solid 1px gray',
                                          padding='0px 30px 20px 30px')

        # Create all components
        self.ui_title = widgets.HTML(value="<h2>Instructor Grading Configuration</h2>")

        self.run_button = widgets.Button(description='Submit', button_style='success', icon='check')
        self.status_output = widgets.Output()
        self.status_output.append_stdout('Waiting...')

        # Setup click behavior
        self.run_button.on_click(self._setup_environment)

        # Reset rest of state
        self.reset_state()

    def reset_state(self, close_all=False):

        if close_all:
            self.learning_objectives_text.close()
            self.file_upload.close()
            self.file_upload_box.close()
            #self.ui_container.close()

        self.learning_objectives_text = widgets.Textarea(value='', description='Learning Objectives',
                                                         placeholder='Learning objectives: 1. Understand and implement classes in object-oriented programming',
                                                         layout=self.items_layout,
                                                         style={'description_width': 'initial'})
        self.file_upload = widgets.FileUpload(
            accept='.zip',  # Accepted file extension e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'
            multiple=False  # True to accept multiple files upload else False
        )
        self.file_upload_box = widgets.HBox([widgets.Label('Upload User Files:\t'), self.file_upload])


        # Create a VBox container to arrange the widgets vertically
        self.ui_container = widgets.VBox([self.ui_title, self.learning_objectives_text,
                                           self.file_upload_box, self.run_button, self.status_output],
                                          layout=self.box_layout)


    def _setup_environment(self, btn):
        grade_settings['learning_objectives'] = self.learning_objectives_text.value
        grade_settings['json_file_path'] = self.file_upload.value

        if self.file_upload.value:
            try:
                input_file = list(self.file_upload.value.values())[0]
                extracted_zip_dir = list(grade_settings['json_file_path'].keys())[0][:-4]
            except:
                input_file = self.file_upload.value[0]
                extracted_zip_dir = self.file_upload.value[0]['name'][:-4]

            self.status_output.clear_output()
            self.status_output.append_stdout('Loading zip file...\n')

            with zipfile.ZipFile(io.BytesIO(input_file['content']), "r") as z:
                z.extractall()
                extracted_files = z.namelist()

            self.status_output.append_stdout('Extracted files and directories: {0}\n'.format(', '.join(extracted_files)))

            # load all json files
            grade_settings['json_files'] = glob.glob(''.join([extracted_zip_dir, '/**/*.json']), recursive=True)

            #status_output.clear_output()
            self.status_output.append_stdout('Loading successful!\nLearning Objectives: {0}\nExtracted JSON files: {1}'.format(grade_settings['learning_objectives'],
                                                                                                        ', '.join(grade_settings['json_files'])))

        else:
            self.status_output.clear_output()
            self.status_output.append_stdout('Please upload a zip file.')

        # Clear values so they're not saved
        self.learning_objectives_text.value = ''
        self.reset_state(close_all=True)
        self.run_ui_container()

        with self.status_output:
            print('Extracted files and directories: {0}\n'.format(', '.join(extracted_files)))
            print('Loading successful!\nLearning Objectives: {0}\nExtracted JSON files: {1}'.format(grade_settings['learning_objectives'],
                                                                                                        ', '.join(grade_settings['json_files'])))
            print('Submitted and Reset all values.')


    def run_ui_container(self):
        display(self.ui_container, clear=True)

# %% ../nbs/GradingUtility.ipynb 8
def set_css():
  display(HTML('''
  <style>
    pre {
        white-space: pre-wrap;
    }
  </style>
  '''))
get_ipython().events.register('pre_run_cell', set_css)

# %% ../nbs/GradingUtility.ipynb 12
def clean_keys(data):
    cleaned_data = []
    for item in data:
        cleaned_item = {}
        for key, value in item.items():
            cleaned_key = key.strip()
            cleaned_value = value.strip() if isinstance(value, str) else value
            cleaned_item[cleaned_key] = cleaned_value
        cleaned_data.append(cleaned_item)
    return cleaned_data

# %% ../nbs/GradingUtility.ipynb 16
def file_upload_json_to_df(upload_json):

  #get middle key of json to extract content
  fname = list(upload_json.keys())[0]

  #load the json; strict allows us to get around encoding issues
  loaded_json = json.loads(upload_json[fname]['content'], strict=False)

  #clean the keys if needed
  loaded_json = clean_keys(loaded_json)

  return pd.DataFrame(loaded_json)

# %% ../nbs/GradingUtility.ipynb 20
def load_json_as_df(fpath):
    # check if file is .json
    if not fpath.endswith('.json'):
        return None

    keys = ["timestamp", "author", "message"]

    df_out = None
    out_error = None

    try:
        # Read JSON file
        with open(fpath, "r") as f:
            json_data = f.read()

        # Load JSON data
        data = json.loads(json_data, strict=False)

        # Quick check to see if we can fix common errors in json
        # 1. JSON responses wrapped in enclosing dictionary
        if isinstance(data, dict):
          if len(data.keys()) == 1:
            data = data[list(data.keys())[0]]
          else:
            data = [data] #convert to list otherwise

        # We only operate on lists of dictionaries
        if isinstance(data, list):
          data = clean_keys(data) #clean keys to make sure there are no unnecessary newlines

          if all(all(k in d for k in keys) for d in data):
              df_out = pd.json_normalize(data)
              if len(df_out) <=1:
                out_error = [fpath, "Warning: JSON keys correct, but something wrong with the overall structure of the JSON when converting to dataframe. The dataframe only has one row. Skipping."]
                df_out = None
          else:
              out_error = [fpath, "Error: JSON Keys are incorrect. Found keys: " + str(list(data[0].keys()))]
        else:
            out_error = [fpath, "Error: Something is wrong with the structure of the JSON."]

    except Exception as e:
        print(f"Error processing file {fpath}: {str(e)}")
        out_error = [fpath, "Fatal System Error: "+str(e)]

    if df_out is not None:
        df_out['filename'] = fpath

    return df_out, out_error

# %% ../nbs/GradingUtility.ipynb 24
def pretty_print(df):
    return display( HTML( df.to_html().replace("\\n","<br>") ) )

# %% ../nbs/GradingUtility.ipynb 28
def save_as_csv(df, file_name):
  df.to_csv(file_name, index=False)

# %% ../nbs/GradingUtility.ipynb 32
def show_json_loading_errors(err_list):
  if err_list:
    print("The following files have the following errors upon loading and will NOT be processed:", '\n'.join(err_list))
  else:
    print("No errors found in uploaded zip JSON files.")

# %% ../nbs/GradingUtility.ipynb 35
default_ai_assisted_setup = output_setup = ("Given the following chat log, create a table with the question number, the question content, answer, "
                  "whether or not the student answered correctly on the first try, and the number of attempts it took to get the right answer. ")

default_ai_assisted_grading_instructions = ("Then, calculate the quiz grade from the total number of assessment questions. "
                  "Importantly, a point should only be granted if an answer was correct on the very first attempt. "
                  "If an answer was not correct on the first attempt, even if it was correct in subsequent attempts, no point should be awarded for that question. ")

bloom_assisted_output_setup = None

bloom_assistedgrading_instructions = """\nEvaluate the student's overall level or engagement and knowledge, based on bloom's taxonomy using their responses.
Bloom's taxonomy is rated on a 1-6 point system, with 1 being remember (recall facts and basic concepts), 2 being understand (explain ideas or concepts),
3 being apply (use information in new situations), 4 being analyze (draw connections among ideas), 5 being evaluate (justify a stand or decision),
and 6 being create (produce new or original work). Assign the interaction a score from 1-6, where 1 = remember, 2 = understand, 3 = apply, 4 = analyze,
5 = evaluate, and 6 = create."""

